diff --git a/backend/server.py b/backend/server.py
index 2276026..19d6cfb 100644
--- a/backend/server.py
+++ b/backend/server.py
@@ -444,26 +444,7 @@ async def shutdown(sid, data=None):
     if data and data.get("restart"):
         print("[SERVER] Restarting application...")
         import subprocess
-        # Use sys.executable to restart the backend with the same python interpreter
-        # and use Popen with a new process group to ensure it survives our exit
-        try:
-            # Re-run the same command that started this script
-            # sys.executable is the path to python.exe
-            # sys.argv[0] is server.py
-            # We want to make sure we are in the right directory
-            backend_dir = os.path.dirname(os.path.abspath(__file__))
-            project_root = os.path.dirname(backend_dir)
-
-            if sys.platform == 'win32':
-                # On Windows, we can use start to launch a new console window or just spawn it detached
-                # npm run dev is what the original code used, maybe it's preferred to restart EVERYTHING
-                # Let's try to stick to what the user had but make it more robust
-                subprocess.Popen("npm run dev", shell=True, cwd=project_root, creationflags=subprocess.CREATE_NEW_CONSOLE)
-            else:
-                subprocess.Popen("npm run dev", shell=True, cwd=project_root)
-        except Exception as e:
-            print(f"[SERVER] Failed to restart: {e}")
-
+        subprocess.Popen("npm run dev", shell=True)
         os._exit(0)
     else:
         os._exit(0)
diff --git a/backend/timer_agent.py b/backend/timer_agent.py
index a048965..d5abbcd 100644
--- a/backend/timer_agent.py
+++ b/backend/timer_agent.py
@@ -5,7 +5,12 @@ import json
 import os
 import math
 import struct
-import pyaudio
+try:
+    import pyaudio
+    HAS_PYAUDIO = True
+except ImportError:
+    pyaudio = None
+    HAS_PYAUDIO = False

 class TimerAgent:
     def __init__(self, session=None, storage_file="timers.json"):
@@ -13,11 +18,17 @@ class TimerAgent:
         self.storage_file = storage_file
         self.active_timers = {}
         self.active_reminders = {}
-        self._pyaudio_instance = pyaudio.PyAudio()
+        if HAS_PYAUDIO:
+            self._pyaudio_instance = pyaudio.PyAudio()
+        else:
+            self._pyaudio_instance = None
         self._load_from_disk()

     def _play_notification_sound(self):
         # A simple notification sound using pyaudio
+        if not HAS_PYAUDIO:
+            print("pyaudio not available, skipping notification sound.")
+            return
         try:
             sample_rate = 44100
             duration = 0.5
diff --git a/electron/main.js b/electron/main.js
index f30353a..86362ce 100644
--- a/electron/main.js
+++ b/electron/main.js
@@ -64,20 +64,69 @@ function createWindow() {
 }

 function startPythonBackend() {
-    const scriptPath = path.join(__dirname, '../backend/server.py');
-    console.log(`Starting Python backend: ${scriptPath}`);
+    const backendDir = path.join(__dirname, '../backend');
+    const projectRoot = path.join(__dirname, '..');
+    const scriptPath = path.join(backendDir, 'server.py');
+
+    // Determine the python executable path
+    let pythonExe = 'python'; // Default fallback
+
+    const venvPath = process.platform === 'win32'
+        ? path.join(projectRoot, '.venv', 'Scripts', 'python.exe')
+        : path.join(projectRoot, '.venv', 'bin', 'python');
+
+    const fs = require('fs');
+    if (fs.existsSync(venvPath)) {
+        pythonExe = venvPath;
+        console.log(`[MAIN] Using virtual environment python: ${pythonExe}`);
+    } else {
+        console.log(`[MAIN] Virtual environment not found at ${venvPath}, falling back to system 'python'`);
+    }
+
+    console.log(`[MAIN] Starting Python backend: ${pythonExe} ${scriptPath}`);

-    // Assuming 'python' is in PATH. In prod, this would be the executable.
-    pythonProcess = spawn('python', [scriptPath], {
-        cwd: path.join(__dirname, '../backend'),
+    pythonProcess = spawn(pythonExe, [scriptPath], {
+        cwd: backendDir,
+        env: { ...process.env, PYTHONUNBUFFERED: '1' }
     });

+    console.log(`[MAIN] Python backend spawned with PID: ${pythonProcess.pid}`);
+
     pythonProcess.stdout.on('data', (data) => {
-        console.log(`[Python]: ${data}`);
+        console.log(`[Python]: ${data.toString().trim()}`);
     });

     pythonProcess.stderr.on('data', (data) => {
-        console.error(`[Python Error]: ${data}`);
+        console.error(`[Python Error]: ${data.toString().trim()}`);
+    });
+
+    pythonProcess.on('close', (code) => {
+        console.log(`[MAIN] Python backend exited with code ${code}`);
+        if (code !== 0 && !isRelaunching) {
+            console.log('[MAIN] Backend crashed unexpectedly. Attempting to restart in 2 seconds...');
+            setTimeout(startPythonBackend, 2000);
+        }
+        pythonProcess = null; // Clear reference
+    });
+
+    pythonProcess.on('error', (err) => {
+        console.error(`[MAIN] Failed to start Python backend: ${err}`);
+        // If it failed and we weren't already trying 'py', try 'py' as a last resort on Windows
+        if (process.platform === 'win32' && pythonExe !== 'py') {
+            console.log('[MAIN] Attempting fallback to "py" launcher...');
+            pythonExe = 'py';
+            pythonProcess = spawn(pythonExe, [scriptPath], {
+                cwd: backendDir,
+                env: { ...process.env, PYTHONUNBUFFERED: '1' }
+            });
+
+            pythonProcess.stdout.on('data', (data) => console.log(`[Python]: ${data.toString().trim()}`));
+            pythonProcess.stderr.on('data', (data) => console.error(`[Python Error]: ${data.toString().trim()}`));
+            pythonProcess.on('close', (code) => {
+                console.log(`[MAIN] Python backend (fallback) exited with code ${code}`);
+                pythonProcess = null;
+            });
+        }
     });
 }

@@ -100,16 +149,59 @@ app.whenReady().then(() => {
         if (mainWindow) mainWindow.close();
     });

+let isRelaunching = false;
+    ipcMain.on('relaunch-app', () => {
+        if (isRelaunching) return;
+        isRelaunching = true;
+        console.log('[MAIN] Relaunching app requested via IPC...');
+
+        // Pass a flag to the new instance to indicate it's a relaunch
+        // Using app.getPath('exe') as the first argument is often more reliable
+        const args = process.argv.slice(1).filter(arg => arg !== '--relaunch').concat(['--relaunch']);
+        console.log(`[MAIN] Relaunching with args: ${args.join(' ')}`);
+
+        try {
+            // It's often safer to use the absolute path to the executable when relaunching
+            app.relaunch({
+                executablePath: process.argv[0],
+                args: args
+            });
+            console.log('[MAIN] Relaunch scheduled.');
+        } catch (err) {
+            console.error('[MAIN] Error during app.relaunch:', err);
+        }
+
+        // Give it a tiny bit of time to ensure relaunch is registered by the OS before we quit
+        setTimeout(() => {
+            console.log('[MAIN] Quitting now for relaunch...');
+            app.quit();
+        }, 500); // Increased delay
+    });
+
+    const isRelaunch = process.argv.includes('--relaunch');
     checkBackendPort(8000).then((isTaken) => {
-        if (isTaken) {
-            console.log('Port 8000 is taken. Assuming backend is already running manually.');
+        console.log(`[MAIN] Initial port check: port 8000 is ${isTaken ? 'TAKEN' : 'FREE'}. isRelaunch: ${isRelaunch}`);
+        if (isTaken && !isRelaunch) {
+            console.log('[MAIN] Port 8000 is taken. Assuming backend is already running manually.');
             waitForBackend().then(createWindow);
         } else {
-            startPythonBackend();
-            // Give it a moment to start, then wait for health check
-            setTimeout(() => {
-                waitForBackend().then(createWindow);
-            }, 1000);
+            if (isTaken && isRelaunch) {
+                console.log('[MAIN] Port 8000 is taken during relaunch. Backend might still be shutting down. Waiting for it to clear...');
+                // If it's a relaunch and port is taken, it's likely the old backend still dying.
+                // We should wait for it to clear, THEN start a new one.
+                waitForPortToClear(8000).then(() => {
+                    console.log('[MAIN] Port cleared. Starting fresh Python backend...');
+                    startPythonBackend();
+                    setTimeout(() => waitForBackend().then(createWindow), 1000);
+                });
+            } else {
+                console.log('[MAIN] Starting Python backend...');
+                startPythonBackend();
+                // Give it a moment to start, then wait for health check
+                setTimeout(() => {
+                    waitForBackend().then(createWindow);
+                }, 1000);
+            }
         }
     });

@@ -137,6 +229,29 @@ function checkBackendPort(port) {
     });
 }

+function waitForPortToClear(port, retries = 20) {
+    return new Promise((resolve) => {
+        const check = () => {
+            checkBackendPort(port).then((isTaken) => {
+                if (!isTaken) {
+                    console.log(`[MAIN] Port ${port} is now clear.`);
+                    resolve();
+                } else if (retries > 0) {
+                    console.log(`[MAIN] Port ${port} still taken, waiting... (${retries} retries left)`);
+                    setTimeout(() => {
+                        retries--;
+                        check();
+                    }, 500);
+                } else {
+                    console.log(`[MAIN] Port ${port} didn't clear in time after 10 seconds. Proceeding anyway but it might fail.`);
+                    resolve();
+                }
+            });
+        };
+        check();
+    });
+}
+
 function waitForBackend() {
     return new Promise((resolve) => {
         const check = () => {
@@ -171,20 +286,26 @@ app.on('window-all-closed', () => {
 });

 app.on('will-quit', () => {
-    console.log('App closing... Killing Python backend.');
+    console.log('[MAIN] App closing... Killing Python backend.');
     if (pythonProcess) {
+        const pid = pythonProcess.pid;
         if (process.platform === 'win32') {
             // Windows: Force kill the process tree synchronously
             try {
                 const { execSync } = require('child_process');
-                execSync(`taskkill /pid ${pythonProcess.pid} /f /t`);
+                console.log(`[MAIN] Executing taskkill for PID ${pid}...`);
+                execSync(`taskkill /pid ${pid} /f /t`);
+                console.log(`[MAIN] taskkill for PID ${pid} completed.`);
             } catch (e) {
-                console.error('Failed to kill python process:', e.message);
+                console.error(`[MAIN] Failed to kill python process ${pid}: ${e.message}`);
             }
         } else {
             // Unix: SIGKILL
+            console.log(`[MAIN] Sending SIGKILL to PID ${pid}...`);
             pythonProcess.kill('SIGKILL');
         }
         pythonProcess = null;
+    } else {
+        console.log('[MAIN] No pythonProcess found to kill.');
     }
 });
diff --git a/src/App.jsx b/src/App.jsx
index 6f6c24f..ccac640 100644
--- a/src/App.jsx
+++ b/src/App.jsx
@@ -573,8 +573,23 @@ function App() {
         socket.on('restart_request', (data) => {
             console.log('Restart request received from backend:', data);
             addMessage('System', 'Update applied. Restarting application...');
-            // Emit back to server to trigger shutdown with restart: true
-            socket.emit('restart_request', { restart: true });
+
+            // Give the user a moment to see the message
+            setTimeout(() => {
+                // If in Electron, use IPC to relaunch
+                if (window.process && (window.process.type === 'renderer' || window.require)) {
+                    try {
+                        const { ipcRenderer } = window.require('electron');
+                        ipcRenderer.send('relaunch-app');
+                    } catch (e) {
+                        console.error("Failed to send relaunch-app via IPC:", e);
+                        socket.emit('restart_request', { restart: true });
+                    }
+                } else {
+                    // Fallback for browser (though not officially supported)
+                    socket.emit('restart_request', { restart: true });
+                }
+            }, 2000);
         });


@@ -669,6 +684,7 @@ function App() {
             socket.off('printer_list');
             socket.off('slicing_progress');
             socket.off('print_status_update');
+            socket.off('restart_request');
             socket.off('error');

             stopMicVisualizer();